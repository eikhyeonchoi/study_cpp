1. 배열
typename variablename[size];
단, size는 상수식이어야 한다
배열은 항상 특정 데이터형의 배열이야하 함, 일반화된 배열형은 없다
char형 배열, int형 배열, long형 배열 등등...

초기화는 {}, 0으로 초기화 {0}
int arr[3] = {1,2,3};
int arr[10] = {0};

괄호를 비워두면 초기화값의 갯수만큼 배열 원소의 갯수를 결정함
int arr[] = {1,2,3,4,5,6,7};
int arr_size = sizeof arr / sizeof (int);

c++11. 
부호가 없어도 됨
int arr[3] {1,2,3};
중괄호를 공백해 모든 배열을 0으로 초기화 가능
int arr[3] {};
narrowing을 방지할 수 있음
long plifs[] = {25, 92, 3.0}; // 허용x 부동소수점형 -> 정수형으로 변환되기 때문에 최기화 실패 3.0은 double형이기 때문에 축소임(double -> long)



2. 문자열
마지막에 널문자가 들어가야지만 문자열이다
char cat[8] = {'a','b','c','d','e','f','g','h','i', '\0'};
위와 동일한 문자열이다 -> 큰따옴표로 묶인  문자열을 문자열 상수라고 한다
char cat[] = "abcdefghi";
큰따옴표를 사용하는 문자열상수와 작은 따옴표를 사용하는 문자 상수는 서로 바꾸어 쓸 수 없다
char shirt_size = 'S'; // 맞다
char shirt_size = "S"; // 틀리다, 데이터형 불일치 "S"는 내부적으로 그 문자열이 저장되어 이쓴ㄴ 메모리 주소를 나타냄 즉 주소를 대입하려고 함 (포인터)
화이트스페이스로 문자열을 결합할 수 있다
cout << "hi" "my name is" " choi" << endl; // hi의 마지막 \0이 m으로 대체되면서 어떠한 빈칸도 생기지 않는다

<cstring> strlen()을 통해 문자열상수의 길이를 알아낼 수 있음
char name[] = "choi\0eeeeeasdmdnmd"; // 일부러 \0을 넣는다면 \0까지의 길이를 알아냄
cout << strlen(name);  // 4

※ 배열은 포인터임
cout << name; // 주소값

문자열입력
char name[20];
char address[40];
cin >> name;
cin >> address;
// 만약 name을 hong kildng 으로 입력했다면 
name에는 hong이, address에는 kildong이 들어감
cin은 화이트스페이스가 있다면 그 문자열이 끝난걸로 간주함
더불어 사용자가 20보다 더 긴 문자열을 입력할 수 있음
-> 한줄을 모두 읽으려면
cin.get(변수, 읽을 문자 수) or cin.getLine(변수, 읽을 문자 수) // 두 함수 모두 개행문자 까지 읽고, cin객체를 리턴함
이 둘의 차이는 getLine()은 개행문자를 \0으로 대체하며 get()은 개행문자까지 큐에 남겨둔다
cin.get(name, 20);    // 개행문자가 큐에 남음
cin.get(address, 40); // 큐에 개행문자가 남아 있기때문에 address에는 아무것도 저장되지 않는다
이를 방지하려면 cin.get(name, 20).get();     // get()을 파라미터 없이 호출하면 딱 문자하나를 읽기 때문에 큐에 남아있는 개행문자를 읽게됨
cin.get() -> 매개 변수에 따라 함수 활용이 달라짐 -> 함수 오버로딩이라고 함
cin.getLine(name, 20).getLine(address, 40); // getLine은 상관없음

문자열과 수치의 혼합입력시 에러
int year;
cin >> year;        // 큐에 개행이 남음
char address[90];
cin >> address;     // 큐에 남은 개행때문에 저장되지 않음

cin >> year;
cin.get();          // 이렇게 해줘야 개행문자를 없앨 수 있음
또는
(cin >> year).get() ;



3. string 클래스




