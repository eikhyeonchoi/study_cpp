1. 배열
typename variablename[size];
단, size는 상수식이어야 한다
배열은 항상 특정 데이터형의 배열이야하 함, 일반화된 배열형은 없다
char형 배열, int형 배열, long형 배열 등등...

초기화는 {}, 0으로 초기화 {0}
int arr[3] = {1,2,3};
int arr[10] = {0};

괄호를 비워두면 초기화값의 갯수만큼 배열 원소의 갯수를 결정함
int arr[] = {1,2,3,4,5,6,7};
int arr_size = sizeof arr / sizeof (int);

c++11. 
부호가 없어도 됨
int arr[3] {1,2,3};
중괄호를 공백해 모든 배열을 0으로 초기화 가능
int arr[3] {};
narrowing을 방지할 수 있음
long plifs[] = {25, 92, 3.0}; // 허용x 부동소수점형 -> 정수형으로 변환되기 때문에 최기화 실패 3.0은 double형이기 때문에 축소임(double -> long)



2. 문자열
마지막에 널문자가 들어가야지만 문자열이다
char cat[8] = {'a','b','c','d','e','f','g','h','i', '\0'};
위와 동일한 문자열이다 -> 큰따옴표로 묶인  문자열을 문자열 상수라고 한다
char cat[] = "abcdefghi";
큰따옴표를 사용하는 문자열상수와 작은 따옴표를 사용하는 문자 상수는 서로 바꾸어 쓸 수 없다
char shirt_size = 'S'; // 맞다
char shirt_size = "S"; // 틀리다, 데이터형 불일치 "S"는 내부적으로 그 문자열이 저장되어 있는 메모리 주소를 나타냄 즉 주소를 대입하려고 함 (포인터)
화이트스페이스로 문자열을 결합할 수 있다
cout << "hi" "my name is" " choi" << endl; // hi의 마지막 \0이 m으로 대체되면서 어떠한 빈칸도 생기지 않는다

<cstring> strlen()을 통해 문자열상수의 길이를 알아낼 수 있음
char name[] = "choi\0eeeeeasdmdnmd"; // 일부러 \0을 넣는다면 \0까지의 길이를 알아냄
cout << strlen(name);  // 4

※ 배열은 포인터임
cout << name; // 주소값

문자열입력
char name[20];
char address[40];
cin >> name;
cin >> address;
// 만약 name을 hong kildng 으로 입력했다면 
name에는 hong이, address에는 kildong이 들어감
cin은 화이트스페이스가 있다면 그 문자열이 끝난걸로 간주함
더불어 사용자가 20보다 더 긴 문자열을 입력할 수 있음
-> 한줄을 모두 읽으려면
cin.get(변수, 읽을 문자 수) or cin.getLine(변수, 읽을 문자 수) // 두 함수 모두 개행문자 까지 읽고, cin객체를 리턴함
이 둘의 차이는 getLine()은 개행문자를 \0으로 대체하며 get()은 개행문자까지 큐에 남겨둔다
cin.get(name, 20);    // 개행문자가 큐에 남음
cin.get(address, 40); // 큐에 개행문자가 남아 있기때문에 address에는 아무것도 저장되지 않는다
이를 방지하려면 cin.get(name, 20).get();     // get()을 파라미터 없이 호출하면 딱 문자하나를 읽기 때문에 큐에 남아있는 개행문자를 읽게됨
cin.get() -> 매개 변수에 따라 함수 활용이 달라짐 -> 함수 오버로딩이라고 함
cin.getLine(name, 20).getLine(address, 40); // getLine은 상관없음

문자열과 수치의 혼합입력시 에러
int year;
cin >> year;        // 큐에 개행이 남음
char address[90];
cin >> address;     // 큐에 남은 개행때문에 저장되지 않음

cin >> year;
cin.get();          // 이렇게 해줘야 개행문자를 없앨 수 있음
또는
(cin >> year).get() ;



3. string 클래스 #include <string>
char배열을 사용하는 것보다 string 클래스를 사용하는것이 더 좋다
대입
char name[20] {"abcde"};
char name2[20];
name = name2; // 틀림, 배열 대입은 불가능함
string name = {"name"};
string name2;
name = name2; // 맞음, 객체 대입임
결합
name + name2; // 가능
추가
name += name2;// 가능
사이즈 
name.size();  // 가능



4. 구조체
struct variable_name {
    int a;
    float b;
    double c;
    ... (구조체 멤버들)
};
외부선언시 모든 함수에서 사용가능 함수안에서 사용시 함수안에서만 사용가능(함수 스코프)

구조체를 만든 후에는 그 데이터형의 변수를 생성할 수 있음
variable_name a;
a.a, a.b, a.c; // 이런식으로 멤버에 접근할 수 있음

선언과 동시에 초기화 할 수 있음
struct temp {
    int a;
    double b;
} a

구조체 배열
struct temp {
    int a;
    double b;
}
temp a[10];                  // 선언
temp a[10] = {{1,2}, {3,4}}; // 초기화

;



5. 공용체
서로 다른 데이터형을 한 번에 한 가지만 보관할 수 있는 데이터 형식임
union only_one {
    int a;
    float b;
    double c;
};
only_one a;
a.a = 10;   // a는 10이다
a.b = 10.1; // a와 b의 타입이 맞지 않아 a에는 쓰레기값이 들어감 만약 타입이 동일하다면 값이 그대로 들어간다

union mix {
    int a;
    strunct {
        int a;
        int b;
    } b;
};



6. 열거체
const를 사용해 기호 상수를 만드는 것에 대한 또 다른 방편

enum color {red, blue, green, yellow, violet}; // 명시하지 않는이상 기본적으로 0부터 들어감 0,1,2,3,4 ...
enum color {red=1, blue=2, green=3, yellow=99, violet}; // 명시할 수 있다, 이때 violet = 100이다

열거체 변수에는 그 데이터형을 정의하는데 사용된 열거자 값들만 대입가능
color a;
a = blue;       // 맞다
a = 2;          // 틀리다
a = red + blue; // 틀리다

int a = 1;
a += blue;      // 맞다, 열거자들은 int형으로 승급할 수 있다

열거체의 값의 범위
최대값 최소값 모두 각각 최대 최소값보다 큰 2의 최소 거듭제곱의 값을 구함
color의 최대값은 100이며 100보다 큰 2의 최소 거듭제곱 128이라 최소 거듭제곱 -1을 해준다 따라서 최대값은 127
color의 최소값은 1이라서 0보다 같거나 크기때문에 최소값은 0인데 만약 최소값이 음수라면
        최대값구하는 것과 마찬가지로 2의 최소 거듭제곱에 -1을 해주고 -를 붙인다 
        예를들어 최소값이 -5면 최소 거듭제곱의 값은 8이고 8 - 1을 해준 후 -을 붙이면 -7이된다
a = color(50); // 50은 열거체 값의 범위에 있기 때문에 가능



7. 포인터와 메모리 해제
컴파일 시간은 소스코드를 실행 코드로 변환하는 시간을 의미한다. ex) 계획에 따라 여행한다
실행 시간은 프로그램이 실제로 실행되는 동안을 의미한다         ex) 기분내키는 대로 여행한다
만약 배열을 사용하는데 원소 200개가 필요하다면 배열선언시 200개를 미리 선언해둬야 하기 때문에 평상시 메모리 낭비가 발생한다
객체지향 프로그래밍에서는 이 배열 크기를 실행 시간에 알려줄 수 있다(미룰 수 있다는 의미)
즉 실행 시간에 배열을 생성한다 -> c++의 new라는 키워드를 사용해 원하는 만큼의 메모리를 대입하고 포인터를 사용해 위치를 추적할 수 있다
int *a; // 이 a는 포인터 변수임 즉 주소값만을 담을 수 있음
int b = 2;
a = 1;       // 불가능, 1은 정수임
a = &b;      // 가능, b변수의 주소값을 대입 => 결국 a,b 모두 메모리에 저장된 2를 가리키고있음
cout << *a;  // 포인터 변수 앞에 *을 사용하면 메모리의 값을 참조할 수 있음
결국 a === &b 이며 *a === b 이다

일반변수와 포인터변수의 차이?
일반변수는 int a 이런식으로 사용한다, 주소는 숨겨져 있어서 주소를 표시하려면 &a를 해야함 + 값만을 담을 수 있다
포인터변수는 일반변수와 반대로 int* a 이런식으로사용, 이건 값이 숨겨져 있어서 값을 찾으려면 *a를 해야함 + 주소만 담을 수 있다

int* a;
이 구문의 뜻
a(포인터)는 int형을 지시하는 포인터
*a는 결국 int형 변수이다 -> 최종적으로 int형 변수가 *a에 저장되고 이 위치는 a에 저장되어있다
단순 포인터가 아니라 항상 어떤 데이터형을 지시하는 포인터
int* b;
*b = 1123123;  // 이렇게하면 1123123이 어디에 저장되는지 알 수 없다

new를 사용한 메모리 대입
int a = 1;
int *b = &a;      // 이렇게하면 값 1을 변수 a를 통해 접근 할 수 있다
int* c = new int; // 이렇게하면 포인터 c를 통해서만 정수 값에 접근할 수 있다, c는 데이터객체(thing)를 지시한다라고 말함
new를 사용하면 메모리 대입이 프로그램이 실행되는 동안에 일어난다(포인터가 아니면 접근이 불가능함)
그리고 int만큼의 메모리를 찾아 필요한 만큼 블록을 대입하고 그 주소를 리턴함(new를 사용하면 주소값이 리턴됨 -> 주소값을 담으려면 포인터 변수가 필요함)
만약 메모리가 부족하면 0을 리턴하게됨 -> null pointer라고 부른다 즉, 지시하는 값이 없음

delete를 사용한 메모리해제
int* ps = new int;
delete ps; // 메모리해제, new를 사용한 이 후에는 언젠가 반드시 delete를 사용해줘야 함(new를 사용했을 때만임)
더불어 이미 해제만 메모리를 다시 해제하려고 해서도 안된다
    new가아닌 포인터변수를 선언하고 초기화하면(int* a = &b) 실행 시간에 메모리를 확보하는게 아니라 컴파일 시간에 미리 확보해놓기 때문에 -> 정적바인딩
    내 생각엔 메모리가 부족하다면 컴파일 자체에서 에러가 나지 않을까 생각됨 new를 사용하면 실행 시간에 메모리를 동적으로 확보하기 때문에 -> 동적바인딩
    메모리가 중간에 부족해버리면 터질듯

new를 사용한 동적배열 생성
int* a = new int[10]; // 첫번재 원소 주소 리턴, a에는 첫 원소의 주소가 들어감, *a는 첫 원소의 실제 값임
delete [] a;          // 동적배열을 해제하려면 []를 써야함
원소에 접근하려면 a[0], a[1] ... 가능
a[0] = 1;
a[1] = 2;
a[2] = 3;
a += 1;   // 이 구문을 실행하면 a[0] = 2, a[1] = 3, a[2] = 쓰레기값 이 된다
즉 포인터 변수에 1을 더하면 값이 그 포인터가 지시하는 데이터형의 바이트 수만큼 증가한다 <-> 단 배열이름 + 1은 불가능 -> 배열이름은 상수이기 때문에 불가능
예를들어 double형을 지시하는 포인터에 1을 더하는 것은 그 포인터의 수치 값에 8을 더하는 것과 동일
a[0] === *a;     // 맞다
a[1] === *(a+1); // 맞다
a[2] === *(a+2); // 맞다
    배열과 포인터(동적배열)의 공통점 & 차이점
    공: 둘 다 첫번째 원소의 주소값을 담고있다
    차: 포인터에 정수를 더하면 (더한 정수 * 데이터 타입의 바이트수) 만큼 값이 증가한다 즉 포인터 주소가 옮겨짐(더한 정수 만큼 다음 원소로)
        배열이름은 상수이기 때문에 정수를 더할 수 없다(새 값을 대입할 수 없다는 의미임, 주소 값을 확인하기 위해 cout 에서 +1을 해줄 순 있다)
        sizeof를 하면 포인터는 포인터 크기를 리턴하고, 배열은 배열크기를 리턴한다

배열 포인터란?
배열 그 자체의 주소를 저장하는 포인터임
int a[] = {1,2,3,4,5};
cout << a;
cout << &a; // a와 &a는 값은 같지만 타입이 다르다 a는 배열 첫 원소의 주소이며 &a는 배열 자체의 주소를 의미함
배열 포인터는 배열 그 자체의 주소를 저장하는 포인터 변수이기 때문에 &a를 대입해줘야한다
int (*b)[5] = &a; // 데이터타입을 맞추고 []안에 원소갯수를 맞춰준다, 결국 포인터 변수임
값을 참조하기 위해선
cout << a[1] << endl;
cout << *(a + 1) << endl;
cout << *(*b + 1) << endl;
    &a를 포인터 변수 b에 담았으니 배열의 첫 원소를 참조하기위해선 *b를 해야지 첫 원소 주소가 된다
    그 주소의 대해 *를 한번 더 해줘야지 참조가 됨(역참조)